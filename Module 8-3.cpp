/*Задание 3. Игрушечная история
Что нужно сделать
Вы решили открыть бизнес по производству игровых деревянных кубиков для детей. Вы узнали, что лучше всего продаются кубики со стороной 5 см в наборах по несколько штук, 
причём кубиков в наборе должно быть достаточно, чтобы сложить из них один большой куб. Для изготовления кубиков к вам в мастерскую 
поступают деревянные бруски в форме прямоугольных параллелепипедов любых размеров.

Для оптимизации бизнес-процессов напишите программу, которая по заданным размерам исходного бруска определяет, сколько кубиков из него можно изготовить,
можно ли из них составить набор для продажи и если можно, то максимальное число кубиков в этом наборе. 
Все кубики должны быть из цельного дерева без использования клея. Размеры бруска — вещественные числа. Обеспечьте контроль ввода.

Например:

Из бруска 20x35x5 можно изготовить 28 кубиков.

Из 28 кубиков можно собрать набор из 27 кубиков.

Пример выполнения

Введите размеры бруска:

X: 5

Y: 35,76

Z: 35,05

Вывод:

Из этого бруска можно изготовить 49 кубиков.

Из них можно составить набор из 27 кубиков.

Рекомендации по выполнению
Кубики изготавливаются только цельными, не из нескольких частей бруска. Минимальный размер бруска — 5x5x5 см. Подумайте как проще разбить брусок на такие кубики.
Минимальный размер набора — 2x2x2 = 8 кубиков.
Что оценивается
Правильно считается количество кубиков, которое можно получить из бруска.
Количество кубиков в наборе не превышает количество кубиков, полученное из бруска.*/

#include <cmath>
#include <iostream>
#include <cfloat>
#include <Windows.h>


int main() {

    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    std::cout << "Введите размеры бруска (в сатиметрах)" << std::endl;
    std::cout << "X: ";
    float xWorkPiece;
    std::cin >> xWorkPiece;
    while ((xWorkPiece - 5.0f) <= FLT_EPSILON) {
        std::cout << "Рзамер должен быть больше 5 см. Введите снова: ";
        std::cin >> xWorkPiece;
    }

    std::cout << "Y: ";
    float yWorkPiece;
    std::cin >> yWorkPiece;
    while ((yWorkPiece - 5.0f) <= FLT_EPSILON) {
        std::cout << "Рзамер должен быть больше 5 см. Введите снова: ";
        std::cin >> yWorkPiece;
    }

    std::cout << "Z: ";
    float zWorkPiece;
    std::cin >> zWorkPiece;
    while ((zWorkPiece - 5.0f) <= FLT_EPSILON) {
        std::cout << "Рзамер должен быть больше 5 см. Введите снова: ";
        std::cin >> zWorkPiece;
    }
    // подсчитываем количество кубиков которые можно сделать из заготовки
    int quantityCube = ((int)xWorkPiece / 5) * ((int)yWorkPiece / 5) * ((int)zWorkPiece / 5);

    // минимальное количество кубиков в одной стороне набора
    int numberSet = 2;
    int quantityCubeSet = std::pow(numberSet, 3);

    if (quantityCube < quantityCubeSet) {
        std::cout << "Из этого бруска можно изготовить " << quantityCube << " кубиков." << std::endl;
        std::cout << "Из невозможно составить минимальный нбор для продажи." << std::endl;
    }
    else {
        while ((quantityCube / quantityCubeSet) > 0) {
            numberSet++;
            quantityCubeSet = std::pow(numberSet, 3);
         }
        std::cout << "Из этого бруска можно изготовить " << quantityCube << " кубиков." << std::endl;
        std::cout << "Из них можно составить набор из " << quantityCubeSet << " кубиков." << std::endl;
    }
}
